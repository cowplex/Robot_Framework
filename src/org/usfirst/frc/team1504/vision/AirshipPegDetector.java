package org.usfirst.frc.team1504.vision;

import java.util.ArrayList;
import java.util.List;
import org.opencv.core.*;
import org.opencv.imgproc.*;

import edu.wpi.first.wpilibj.vision.VisionPipeline;

/**
* GreenDetectFastBoiler class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
public class AirshipPegDetector implements VisionPipeline
{

	//Outputs
	private Mat cvExtractchannel0Output = new Mat();
	private Mat cvExtractchannel1Output = new Mat();
	private Mat cvSubtractOutput = new Mat();
	private Mat cvThresholdOutput = new Mat();
	private ArrayList<MatOfPoint> findContoursOutput = new ArrayList<MatOfPoint>();
	private ArrayList<MatOfPoint> filterContoursOutput = new ArrayList<MatOfPoint>();
	
	private double cvThresholdThresh = 60.0;
	
	private MatOfPoint biggest_contours[] = new MatOfPoint[2];
	private double biggest_contours_area[];

	static
	{
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
	}

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	public void process(Mat source0)
	{
		ArrayList<Mat> split = new ArrayList<Mat>();
		Core.split(source0, split);
		cvExtractchannel0Output = split.get(1);
		cvExtractchannel1Output = split.get(2);
		

		// Step CV_subtract:
		Mat cvSubtractSrc1 = cvExtractchannel0Output;
		Mat cvSubtractSrc2 = cvExtractchannel1Output;
		cvSubtract(cvSubtractSrc1, cvSubtractSrc2, cvSubtractOutput);

		// Step CV_Threshold:
		Mat cvThresholdSrc = cvSubtractOutput;
		double cvThresholdMaxval = 255.0;
		int cvThresholdType = Imgproc.THRESH_BINARY;
		cvThreshold(cvThresholdSrc, cvThresholdThresh, cvThresholdMaxval, cvThresholdType, cvThresholdOutput);

		// Step Find_Contours:
		Mat findContoursInput = cvThresholdOutput;
		boolean findContoursExternalOnly = false;
		findContours(findContoursInput, findContoursExternalOnly, findContoursOutput);

		// Step Filter_Contours: (Finds the N largest blobs and puts them into an array)
		int smaller = 0;
		biggest_contours_area = new double[biggest_contours.length];
		for (int i = 0; i < findContoursOutput.size(); i++)
		{
			MatOfPoint contour = findContoursOutput.get(i);
			double area = Imgproc.contourArea(contour);
			if(area > biggest_contours_area[smaller])
			{
				biggest_contours[smaller] = contour;
				biggest_contours_area[smaller] = area;
				
				// Find the smaller value in the array
				for(int j = 0; j < biggest_contours.length; j++)
				{
					if(biggest_contours_area[i] < biggest_contours_area[smaller])
						smaller = i;
				}
				
			}
		}
	}

	/**
	 * This method is a generated getter for the output of a CV_extractChannel.
	 * @return Mat output from CV_extractChannel.
	 */
	public Mat cvExtractchannel0Output() {
		return cvExtractchannel0Output;
	}

	/**
	 * This method is a generated getter for the output of a CV_extractChannel.
	 * @return Mat output from CV_extractChannel.
	 */
	public Mat cvExtractchannel1Output() {
		return cvExtractchannel1Output;
	}

	/**
	 * This method is a generated getter for the output of a CV_subtract.
	 * @return Mat output from CV_subtract.
	 */
	public Mat cvSubtractOutput() {
		return cvSubtractOutput;
	}

	/**
	 * This method is a generated getter for the output of a CV_Threshold.
	 * @return Mat output from CV_Threshold.
	 */
	public Mat cvThresholdOutput() {
		return cvThresholdOutput;
	}

	/**
	 * This method is a generated getter for the output of a Find_Contours.
	 * @return ArrayList<MatOfPoint> output from Find_Contours.
	 */
	public ArrayList<MatOfPoint> findContoursOutput() {
		return findContoursOutput;
	}

	/**
	 * This method is a generated getter for the output of a Filter_Contours.
	 * @return ArrayList<MatOfPoint> output from Filter_Contours.
	 */
	public ArrayList<MatOfPoint> filterContoursOutput() {
		return filterContoursOutput;
	}

	/**
	 * Subtracts the second Mat from the first.
	 * @param src1 the first Mat
	 * @param src2 the second Mat
	 * @param out the Mat that is the subtraction of the two Mats
	 */
	private void cvSubtract(Mat src1, Mat src2, Mat out) {
		Core.subtract(src1, src2, out);
	}

	/**
	 * Apply a fixed-level threshold to each array element in an image.
	 * @param src Image to threshold.
	 * @param threshold threshold value.
	 * @param maxVal Maximum value for THRES_BINARY and THRES_BINARY_INV
	 * @param type Type of threshold to appy.
	 * @param dst output Image.
	 */
	private void cvThreshold(Mat src, double threshold, double maxVal, int type,
		Mat dst) {
		Imgproc.threshold(src, dst, threshold, maxVal, type);
	}

	/**
	 * Sets the values of pixels in a binary image to their distance to the nearest black pixel.
	 * @param input The image on which to perform the Distance Transform.
	 * @param type The Transform.
	 * @param maskSize the size of the mask.
	 * @param output The image in which to store the output.
	 */
	private void findContours(Mat input, boolean externalOnly,
		List<MatOfPoint> contours) {
		Mat hierarchy = new Mat();
		contours.clear();
		int mode;
		if (externalOnly) {
			mode = Imgproc.RETR_EXTERNAL;
		}
		else {
			mode = Imgproc.RETR_LIST;
		}
		int method = Imgproc.CHAIN_APPROX_SIMPLE;
		Imgproc.findContours(input, contours, hierarchy, mode, method);
	}
	
	/**
	 * Sets the desired openCV threshold level
	 * @param threshold The threshold point
	 */
	public void setThreshold(double threshold)
	{
		cvThresholdThresh = threshold;
	}

}

